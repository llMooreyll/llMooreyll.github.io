<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>2D Game and Shader in Godot Engineg</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100;300;400;500;700;900&family=Rubik+Dirt&family=Rubik+Mono+One&display=swap" rel="stylesheet">
        <link href="./assets/css/main.css" rel="stylesheet" />
        <link href="./assets/css/github-markdown.css" rel="stylesheet" />
        <link href="./assets/css/MdPassage.css" rel="stylesheet" />
        <script src="./assets/js/markdown-it.min.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="./assets/js/MdToHtm.js" defer="defer"></script>
        <title>How_to_Shader</title>
    </head>

    <body>
        <nav class="navbar navbar-expand-lg navbar-light fixed-top semi-transparent">
            <div class="secondary-container container" style="top: 0%">
                <a class="navbar-brand" href="./index.html"><strong>Orey's</strong><sub style="font-size: 20px">Blog </sub></a>
                <div class="navbar-collapse collapse" id="navbarColor02">
                    <ul class="navbar-nav mr-auto d-flex align-items-center">
                        <li class="nav-item">
                            <a class="nav-link btn" href="./index.html">Home <span class="sr-only">(current)</span></a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link btn" href=" ">Projects</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link btn" href=" ">Collections</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link btn" href=" ">About</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- HEADER -->
        <div class="container-top">
            <div
                class="passage-head-image head-image"
                id="parallax-img"
                style="
                    background-image: url(./assets/img/Godot/godot-4-0-sets-sail.jpg);
                    transform: translate3d(0, 0, 0);
                    background-size: cover;
                    background-repeat: no-repeat;
                "
            ></div>
            <div class="passage-wrapper wrapper">
                <div class="post-header">
                    <h1 class="post-title">Shader in Godot (1)</h1>
                    <h2 class="post-secondary-title">
                    </h2>
                    <span class="post-meta"><i>Posted by Moorey on Feb 26, 2023</i></span>
                </div>
            </div>
        </div>
        <!-- End Header -->
        <div class="markdown-body" id="raw-markdown-body">
# Godot中2D游戏与着色器

## **着色器** (Shader)的分类 ?
- Godot中着色器主要分为三类:  
顶点着色器(Vertex Shader),片段着色器(Fragment Shader),光线着色器(Light Shader)  
2D游戏中主要运用片段着色器.
## 什么是 **片段着色器** (Fragment Shader) ?
- 如果你曾经有用计算机绘图的经验，你就知道在这个过程中你需要画一个圆，然后一个长方形，一条线，一些三角形……直到画出你想要的图像。这个过程很像用手写一封信或一本书 —— 都是一系列的指令，需要你一件一件完成。Fragment Shader 也是一系列的指令，但是这些指令会对屏幕上的每个像素同时下达。就像活字印刷，你的程序就像一个函数(Function)，输入位置信息，输出颜色信息，当它编译完之后会以相当快的速度运行。


## Hello,World !

### 编写第一个片段着色器
- 在Godot中, 对于所有的着色器,第一行用于指定着色器类型,现在让我们声明一个2D着色器,格式如下:  
`shader_type canvas_item;`  
接下来声明变量(如果需要),如下:  
`uniform vec4 line_color : source_color`  
`uniform float line_thickness : hint_range(1.0, 20.0) = 10.0;`  
`...`  
`vec4` 是定义一个四维向量,我们用r(红色通道),g(绿色通道),b(蓝色通道),a(透明度值)即一个四维向量来定义一个颜色.  
由`uniform`关键字定义的变量可以在着色器外部接收值,变量会显示在 `Inspector` 栏 `Material` >> `Shader Param` 下:  
`hint_range` 在允许接受一个介于第一第二参数之前的值, `source_color`会在面板开一个选色板,方便快速选色  
![Inspector选项卡](./assets/img/Godot/9523f7e29c14d25e5a331237f6ea27c7.png)  
在片段着色器中,可以通过重写**片段函数**(fragment)来控制着色器的运作.片段函数同时作用于每个像素,决定每个像素最终应该是什么颜色,最简单的片段函数,仅仅给像素赋一个颜色值,格式如下:
```C
void fragment(){
    COLOR = vec4(0.4, 0.6, 0.9, 1.0);
}
```
这个片段函数向内置变量 `COLOR` 中写入一个 `vec4` 来做到这点.  
这即是一个简单的片段着色器,完整代码如下:
```C
//着色器类型声明
shader_type canvas_item;
//变量定义,本例中未使用变量,以下变量定义仅作示范
uniform float line_thickness : hint_range(1.0, 20.0) = 10.0;
uniform vec4 line_color : source_color;
//片段函数定义
void fragment(){
    COLOR = vec4(0.4, 0.6, 0.9, 1.0);
}
```

效果如下:  
![简单着色器](./assets/img/Godot/b0475b7bb5c52f25da62b851e74319d2.png)


## 实现简单特效

### 使用片段着色器实现图像**描边**特效
- 首先声明着色器类型为`canvas_item`,如下:  
`shader_type canvas_item;`<br/>
- 使用 `uniform` 关键字定义一个**浮点**类型全局变量`line_thickness`保存描边线的宽度,默认值5.0,如下:  
`uniform float line_thickness : hint_range(1.0, 20.0) = 5.0;`  
再定义一个全局**四维**变量`line_color`保存描边线颜色,如下:  
`uniform vec4 line_color : source_color;`  
接下来定义片段着色器函数,如下:
```C
void fragment(){
    ...
}
```
- 片段函数算法:
    + 计算机如何找到Sprite 的边界?
        * Sprite 中的像素可以分为三类:
            - 第一类是图片内部的像素(即透明度不为0的像素)
            - 第二类是图片外部的像素(即透明度为0的像素)
            - 第三类是图片边沿的像素(即透明度为0但相邻的像素至少有一个透明度不为0)
        * 那么我们就可以用判断一个像素周边透明度的办法来判断该像素是不是边沿像素(第三类像素)  
        如果是,赋予其一个颜色,即可达到描边效果
    ![三类像素](./assets/img/Godot/2023-01-30_17.52.25.png)
    + 算法实现:
        * (不应使用)用1.0(注意操作符两边的操作数类型必须相同所以使用1.0)分别除以图像的长和宽(用 `textureSize( )` 函数获取).将图像的长宽映射到1.0\*1.0的'UV坐标系中
        * 直接使用片段函数内置变量(Fragment built-ins Variable) `TEXTURE_PIXEL_SIZE` 获取默认2D纹理的标准像素大小(normalized pixel size)
        * 通过  `texture( )` 函数读取某像素的透明度通道值,将该值乘以8并依次减去周围八个像素的透明度值
        * 结果小于零的像素就是第三类像素即边沿像素  
        ![Godot Document >>Shaders>>Shading reference>>CanvasItem shaders>>Fragment built-ins](.\assets\img\Godot\2023-02-01_22-36-17.png)
    + 代码实现:
    ```C
    void fragment(){
        //float Xbenchmark = 1.0/float(textureSize(TEXTURE, 0).x);
        //float Ybehchmark = 1.0/float(textureSize(TEXTURE, 0).y);
        vec2 benchmark = TEXTURE_PIXEL_SIZE;
        
        COLOR = texture(TEXTURE, UV);
        float alpha = texture(TEXTURE, UV).a*8.0;
        alpha -= texture(TEXTURE, UV - vec2(0, line_width*Ybehchmark)).a;
        alpha -= texture(TEXTURE, UV + vec2(0, line_width*Ybehchmark)).a;
        alpha -= texture(TEXTURE, UV - vec2(line_width*Xbenchmark, 0)).a;
        alpha -= texture(TEXTURE, UV + vec2(line_width*Xbenchmark, 0)).a;
        alpha -= texture(TEXTURE, UV - vec2(line_width*Xbenchmark, line_width*Ybehchmark)).a;
        alpha -= texture(TEXTURE, UV + vec2(line_width*Xbenchmark, line_width*Ybehchmark)).a;
        alpha -= texture(TEXTURE, UV - vec2(line_width*Xbenchmark, -line_width*Ybehchmark)).a;
        alpha -= texture(TEXTURE, UV + vec2(line_width*Xbenchmark, -line_width*Ybehchmark)).a;
        
        if(alpha < 0.0){
            COLOR = line_color;
        }
    }
    ```
    + 调整描边线宽度:
        - 通过读取距被采样像素更远的八个像素,并将透明度值作比较,读取的像素距离与被采样像素越远,描边线越宽
- 完整代码优化后如下:
```C
shader_type canvas_item;

uniform float line_thickness : hint_range(1.0, 20.0) = 10.0;
uniform vec4 line_color : source_color;
    
void fragment(){
    vec2 benchmark = TEXTURE_PIXEL_SIZE * line_thickness;
    
    COLOR = texture(TEXTURE, UV);
    float alpha = texture(TEXTURE, UV).a*8.0;
    alpha -= texture(TEXTURE, UV - vec2(0, benchmark.y)).a;
    alpha -= texture(TEXTURE, UV + vec2(0, benchmark.y)).a;
    alpha -= texture(TEXTURE, UV - vec2(benchmark.x, 0)).a;
    alpha -= texture(TEXTURE, UV + vec2(benchmark.x, 0)).a;
    alpha -= texture(TEXTURE, UV - vec2(benchmark.x, benchmark.y)).a;
    alpha -= texture(TEXTURE, UV + vec2(benchmark.x, benchmark.y)).a;
    alpha -= texture(TEXTURE, UV - vec2(benchmark.x, -benchmark.y)).a;
    alpha -= texture(TEXTURE, UV + vec2(benchmark.x, -benchmark.y)).a;
    
    if(alpha < 0.0){
        COLOR = line_color;
    }
}
```
- 效果如下:  
![最终效果](./assets/img/Godot/2023-01-30_22-24-23.jpg)<br/>


## External links
>Godot official website : https://godotengine.org/  
>Godot Docs : https://docs.godotengine.org/en/stable/  
>Create a Complete 2D Platformer in the Godot Engine : https://www.udemy.com/course/create-a-complete-2d-platformer-in-the-godot-engine/  
>2.5D parallax effect in GODOT 2D engine. Similar to the background parallax in Hollow knight : https://www.youtube.com/watch?v=kBJhEGyVKd8&ab_channel=Nonsensical2D  
>How To Shader (Fast) - using Godot Engine : https://www.youtube.com/watch?v=1pJyYtBAHks&ab_channel=PlayWithFurcifer  
>How To Shader. (using Godot Engine) : https://www.youtube.com/watch?v=KVTa2xkly1g&t=319s&ab_channel=PlayWithFurcifer  
>How to make 3D Pixel Art in Godot : https://www.youtube.com/watch?v=qRAeiwTA7qs&t=95s&ab_channel=LeonStansfield  
>The Book of Shader : https://thebookofshaders.com  
        </div>
        <div id="category"></div>
    </body>
    <script src="./assets/js/parallax.js" type="text/javascript"></script>
    <script>hljs.highlightAll();</script>
</html>
